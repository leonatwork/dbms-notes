(this["webpackJsonpdbms-notes"]=this["webpackJsonpdbms-notes"]||[]).push([[0],{21:function(e,l,t){e.exports=t(34)},33:function(e,l,t){},34:function(e,l,t){"use strict";t.r(l);var a=t(0),n=t.n(a),r=t(10),i=t.n(r),c=(t(26),t(11)),o=t(12),u=t(15),s=t(13),m=t(8),E=t(18),d=function(e){Object(u.a)(t,e);var l=Object(s.a)(t);function t(){var e;Object(c.a)(this,t);for(var a=arguments.length,n=new Array(a),r=0;r<a;r++)n[r]=arguments[r];return(e=l.call.apply(l,[this].concat(n))).state={navExpanded:!1},e}return Object(o.a)(t,[{key:"render",value:function(){var e=this,l={backgroundColor:"#BBDEFB"},t={color:"white",fontSize:"28px",fontFamily:"'Merienda One', cursive"};return this.props.showNav?n.a.createElement(m.a,{collapseOnSelect:!0,style:l,expand:"lg"},n.a.createElement(m.a.Brand,{style:t,href:"https://leonatwork.github.io/dbms-notes/"},"DBMS Notes"),n.a.createElement(m.a.Toggle,{"aria-controls":"basic-navbar-nav"}),n.a.createElement(m.a.Collapse,{id:"basic-navbar-nav"},n.a.createElement(E.a,{className:"mr-auto"},this.props.notes.map((function(l){var t="list-group-item";return l.id===e.props.activeNoteID&&(t+=" active-me"),n.a.createElement(E.a.Link,{key:l.id,href:"#"+l.id,className:t,onClick:function(){return e.props.handleClick(l.id)},style:{cursor:"pointer",textAlign:"center"}},l.title)}))))):n.a.createElement(m.a,{expand:"lg",style:l},n.a.createElement(m.a.Brand,{href:"https://leonatwork.github.io/dbms-notes/",style:t},"DBMS Notes"))}}]),t}(a.Component),h=function(e){var l=e.notes,t=e.activeNoteID,a=e.handleClick;return n.a.createElement("ul",{className:"list-group list-group-flush"},l.map((function(e){var l="list-group-item";return e.id===t&&(l+=" active"),n.a.createElement("li",{key:e.id,className:l,onClick:function(){return a(e.id)},style:{cursor:"pointer"}},e.title)})))},b=function(e){var l=e.note;return n.a.createElement(n.a.Fragment,null,l)},p=[{id:0,title:"Introduction",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Introduction"),n.a.createElement("hr",null),n.a.createElement("p",null,n.a.createElement("b",null,"Database")," is a collection of related data."),n.a.createElement("p",null,n.a.createElement("b",null,"DBMS (Database Management System) "),"is the software used to create/manipulate/manage/update/delete database"),n.a.createElement("p",null,n.a.createElement("b",null,"Data")," includes all the raw facts and figures"),n.a.createElement("p",null,n.a.createElement("b",null,"Information")," is the processed data"),n.a.createElement("p",null,"Data and information are subjective and the seperation depends on who uses it and the situation.",n.a.createElement("br",null)," ",n.a.createElement("b",null,"Eg.")," A grocery list may be an information to the customer, but it may just be a data to a market analyst."),n.a.createElement("hr",null),n.a.createElement("h3",null,"Why was DBMS developed?"),n.a.createElement("h6",null,"Disadvantages of traditional file-system"),n.a.createElement("ul",null,n.a.createElement("li",null,"Data redundancy"),n.a.createElement("li",null,"Data inconsistency"),n.a.createElement("li",null,"Access difficulty"),n.a.createElement("li",null,"Data isolation"),n.a.createElement("li",null,"Security problem"),n.a.createElement("li",null,"Atomicity problem"),n.a.createElement("li",null,"Concurrent access problem"),n.a.createElement("li",null,"Integrity issues")),n.a.createElement("hr",null),n.a.createElement("h3",null,"Online Data Processing Systems"),n.a.createElement("h6",null,"OLAP (Online Analytical Processing)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Consists of historical data"),n.a.createElement("li",null,"Subject oriented"),n.a.createElement("li",null,"Used for decision making"),n.a.createElement("li",null,"Larger in size (TB, PB)"),n.a.createElement("li",null,"Only Read operations")),n.a.createElement("h6",null,"OLTP (Online Transaction Processing)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Consists of current data"),n.a.createElement("li",null,"Application oriented"),n.a.createElement("li",null,"Used for day to day operations"),n.a.createElement("li",null,"Smaller in size (MB, GB)"),n.a.createElement("li",null,"Both read and write operations")))},{id:1,title:"ER diagram",content:n.a.createElement("div",null,n.a.createElement("h1",null,"ER diagram"),n.a.createElement("hr",null),n.a.createElement("h4",null,"Entity Relationship Diagram"),"High level diagram giving a conceptual understanding of the relational model (entities and their relationship)",n.a.createElement("br",null),"Introduced by Peter Chen",n.a.createElement("hr",null),n.a.createElement("h4",null,"Entity"),n.a.createElement("b",null,"Entity "),"is a real world thing or object, distinguishable from others based on its attributes. ",n.a.createElement("br",null),"Types :",n.a.createElement("ol",null,n.a.createElement("li",null,"Tangible : physically exist. ",n.a.createElement("b",null,"Eg.")," bank locker, car"),n.a.createElement("li",null,"Intangible : exists logically. ",n.a.createElement("b",null,"Eg.")," bank account")),n.a.createElement("hr",null),n.a.createElement("h4",null,"Attribute"),n.a.createElement("b",null,"Attributes "),"are entity's characteristics. Represented with oval (column)",n.a.createElement("br",null),"Attribute types:",n.a.createElement("ol",null,n.a.createElement("li",null,"Simple : cannot be decomposed"),n.a.createElement("li",null,"Composite : can be decomposed ",n.a.createElement("b",null,"Eg.")," name = first name + last name"),n.a.createElement("li",null,"Single-valued"),n.a.createElement("li",null,"Multi-valued (double oval) (we have to make separate table for it)"," ",n.a.createElement("b",null,"Eg.")," phone no."),n.a.createElement("li",null,"Stored "),n.a.createElement("li",null,"Derived (dotted oval) ",n.a.createElement("b",null,"Eg.")," age can be derived from DOB")),n.a.createElement("hr",null),n.a.createElement("h4",null,"Relationship"),n.a.createElement("b",null,"Relationship")," is represented by a diamond",n.a.createElement("br",null),"A relationship has",n.a.createElement("ol",null,n.a.createElement("li",null,"Name"),n.a.createElement("li",null,"Degree (no. of entites participating in the relation) (like unary, binary, ternary, ..., n-ary)"),n.a.createElement("li",null,"Cardinality ratio / participation constraints (like one to one, one to many) (for binary relations)")),n.a.createElement("b",null,"Cardinality ratio")," express the number of entities to which an entity can be related. ",n.a.createElement("br",null),"It can be 1 : 1, 1 : n, n : 1 or n : n",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Participation constraints "),"specifies the maximum and minimum no. of relationship an entity can/must participate in max cardinality and min cardinality. ",n.a.createElement("b",null,"Eg.")," 1 project can have min 3 employees and 1 project can have max 15 employees (min, max) = (3, 15)",n.a.createElement("br",null),"partial participation - min cardinality = 0 (single line)",n.a.createElement("br",null)," total participation - min cardinality ",">","= 1 (double line)",n.a.createElement("hr",null),n.a.createElement("h4",null,"Entity set"),n.a.createElement("b",null,"Entity set "),"is the set of similar type of entities. Represented by a rectangle in ER diagram (tables)",n.a.createElement("br",null),"ER diagram represents entity set (student) and not the entity (Sam)",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Weak entity set "),"(double rectangle) is an entity that cannot be uniquely identified by its attributes alone. The entity sets which do not have sufficient attributes to form a primary key are known as weak entity sets.",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Strong entity set "),"(simple rectangle) the entity sets which have a primary key are known as strong entity sets.",n.a.createElement("br",null),"The relation between one strong and one weak entity is represented by double diamond. Weak entities always have total participation but strong entities may not have total participation.")},{id:2,title:"Keys",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Keys"),n.a.createElement("hr",null),n.a.createElement("p",null,n.a.createElement("b",null,"Keys")," are the attribute or set of attributes which can uniquely identify a record."),n.a.createElement("div",null,n.a.createElement("b",null,"Types of keys"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Super key :")," set of all possible keys"),n.a.createElement("li",null,n.a.createElement("b",null,"Candidate key :")," minimal subset of superkey which can uniquely identify a record, i.e given a super key then no proper subset of the super key should uniquely identify a record, then that superkey is a candidate key"),n.a.createElement("li",null,n.a.createElement("b",null,"Primary key :")," the candidate key chosen to uniquely identify a record"),n.a.createElement("li",null,n.a.createElement("b",null,"Foreign key :")," an attribute in table which is used to define its relationship with another table"),n.a.createElement("li",null,n.a.createElement("b",null,"Composite key :")," key with more than one attribute (if one attribute of composite key is foriegn key then it is called as"," ",n.a.createElement("b",null,"compound key"),")"),n.a.createElement("li",null,n.a.createElement("b",null,"Alternate key :")," candidate keys - primary key"),n.a.createElement("li",null,n.a.createElement("b",null,"Surrogate key :")," if no attribute or its combination can uniquely identify a record then we introduce a new attribute called surrogate key only for the identification purpose"))))},{id:3,title:"Functional dependencies",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Functional dependencies"),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("b",null,"f: a -",">"," b"),n.a.createElement("p",null,"Given the value of ",n.a.createElement("b",null,"a"),", we can uniquely determine the value of",n.a.createElement("b",null," b"),"."),n.a.createElement("p",null,n.a.createElement("b",null,"Trivial functional dependency : "),n.a.createElement("b",null,"b")," is a subset of",n.a.createElement("b",null," a"),"."),n.a.createElement("p",null,n.a.createElement("b",null,"Non-trivial functional dependency : "),n.a.createElement("b",null,"b")," is a NOT a subset of",n.a.createElement("b",null," a"),"."),n.a.createElement("p",null,n.a.createElement("b",null,"Attribute closure")," of an attribute set ",n.a.createElement("b",null,"A")," can be defined as a set of attributes which can be functionally determined from it. It is denoted by",n.a.createElement("b",null," ","F",n.a.createElement("sup",null,"+"),"."))),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"Armstrong axioms"),n.a.createElement("p",null,"Axioms are the rules which are considered true and used to derive other results."),n.a.createElement("b",null,"Primary rules"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Reflexivity"),n.a.createElement("p",null,"If y is subset of x then x -",">"," y")),n.a.createElement("li",null,n.a.createElement("b",null,"Augmentation"),n.a.createElement("p",null,"x -",">"," y then xz -",">"," yz")),n.a.createElement("li",null,n.a.createElement("b",null,"Transitivity"),n.a.createElement("p",null,"x -",">"," y and y -",">"," z then x -",">"," z"))),n.a.createElement("b",null,"Secondary rules"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Union"),n.a.createElement("p",null,"x -",">"," y and x -",">"," z then x -",">"," yz")),n.a.createElement("li",null,n.a.createElement("b",null,"Decomposition"),n.a.createElement("p",null,"x -",">"," yz then x -",">"," y and x -",">"," z")),n.a.createElement("li",null,n.a.createElement("b",null,"Pseudo transitivity"),n.a.createElement("p",null,"x -",">"," y and wy -",">"," z then xw -",">"," zz")),n.a.createElement("li",null,n.a.createElement("b",null,"Composition"),n.a.createElement("p",null,"x -",">"," y and z -",">"," w then xz -",">"," yw")))),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"Canonical form"),n.a.createElement("p",null,"It is the irreducible set of functional dependencies."),n.a.createElement("b",null,"Steps"),n.a.createElement("ol",null,n.a.createElement("li",null,"Decompose all dependencies"),n.a.createElement("li",null,"For all the rules :",n.a.createElement("ol",null,n.a.createElement("li",null,"Find closure of the LHS of a rule"),n.a.createElement("li",null,"Find closure of the lhs of the same rule ignoring that rule itself"),n.a.createElement("li",null,"If both closures are same then that rule is redundant so remove it otherwise include it"))),n.a.createElement("li",null,"For all the rules :",n.a.createElement("ol",null,n.a.createElement("li",null,"If LHS is compound then find its closure and closure of each subset of elements in it"),n.a.createElement("li",null,"If closure of particular element matches the main closure then other elements on LHS are redundant")))),n.a.createElement("p",null,"Finally the set of rules you have is the canonical form/canonical cover/minimal cover/irreducible form.")))},{id:4,title:"Normalization",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Normalization"),n.a.createElement("hr",null),n.a.createElement("p",null,n.a.createElement("b",null,"Normalization")," is the method to organize data into multiple related tables to avoid data redundancy."),n.a.createElement("div",null,n.a.createElement("b",null,"Redundancy issues"),n.a.createElement("br",null),"Consider a table student table (roll no, name, branch name, HOD name, HOD phone no)",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Insertion anomaly"),n.a.createElement("p",null,"Inserting redundant data (HOD info) for every new entry of a student. Also new student record cannot be created if HOD information is not available, even though both are logically seperate entities.")),n.a.createElement("li",null,n.a.createElement("b",null,"Deletion anomaly"),n.a.createElement("p",null,"This happens when two separate items have the same table and we wish to delete entry of one item and other also gets deleted."," ",n.a.createElement("br",null),n.a.createElement("b",null,"Eg.")," If student info is deleted then HOD's info also gets deleted.")),n.a.createElement("li",null,n.a.createElement("b",null,"Updation anomaly"),n.a.createElement("p",null,"If a value is updated then all its redundant copies needs to be updated. ",n.a.createElement("br",null),n.a.createElement("b",null,"Eg. "),"If HOD phone no. is updated then for every student entry we need to update it.")))),n.a.createElement("hr",null),n.a.createElement("h4",null,"Normalization forms"),n.a.createElement("div",null,n.a.createElement("b",null,"1 NF"),n.a.createElement("ul",null,n.a.createElement("li",null,"Each column should contain atomic values (i.e each column has a single value)"),n.a.createElement("li",null,"A column should contain value of the same type"),n.a.createElement("li",null,"Each column should have a unique name"),n.a.createElement("li",null,"Order in which data is stored in table doesn't matter")),n.a.createElement("b",null,"2 NF"),n.a.createElement("ul",null,n.a.createElement("li",null,"Table should be in 1 NF"),n.a.createElement("li",null,"Table should not have any ",n.a.createElement("b",null,"partial dependencies")," (partial prime attr. -",">"," non prime attr.) i.e. if primary key of the table is composition of more tham 1 columns and a particular column of the table only depends on a subset of the primary key columns and has nothing to do with other columns of the primary key"),n.a.createElement("li",null,"While decomposing a table, we always make a seperate table for candidate keys otherwise it will be a lossy decomposition.")),n.a.createElement("b",null,"3 NF"),n.a.createElement("ul",null,n.a.createElement("li",null,"Table should be in 2 NF"),n.a.createElement("li",null,"Table should not have ",n.a.createElement("b",null,"transitive dependency")," (non prime attr. -",">"," non prime attr.) i.e. when there is an attribute in a table which depends upon non-prime attribute which inturn depends on the prime attributes")),n.a.createElement("b",null,"BCNF (Boyce Codd Normal Form - 3.5 NF)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Table should be in 3 NF"),n.a.createElement("li",null,"For any dependency A -",">"," B, A should be super key i.e no dependencty of type (non prime attr -",">"," prime attr)"),n.a.createElement("li",null,"Conversions from 1 NF to 2 NF and 2 NF to 3 NF will not result in any loss of functional dependencies. But conversion from 3 NF to BCNF may sometimes result in functional dependency loss.",n.a.createElement("br",null),"Decomposing R to R1 and R2 will be loss-less if :",n.a.createElement("ul",{style:{listStyleType:"none"}},n.a.createElement("li",null,"attr(R1) U attr(R2) = attr(R)"),n.a.createElement("li",null,"attr(R1) \u2229 attr(R2) = \u03a6"),n.a.createElement("li",null,"attr(R1) \u2229 attr(R2) = key of (R1) or attr(R1) \u2229 attr(RR2) = key of (R2)")))),n.a.createElement("b",null,"4 NF"),n.a.createElement("ul",null,n.a.createElement("li",null,"Table should be in BCNF"),n.a.createElement("li",null,"Table should not have multi-valued dependency i.e. if A -",">"," B then for a particular value of A there exists multiple values of B"),n.a.createElement("li",null,"For table to have multi-valued dependency it should have at least 3 columns (A,B,C) and B,C should be independent")),n.a.createElement("b",null,"5 NF (PJNF - Project Join Normal Form)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Table should be in 4 NF"),n.a.createElement("li",null,"Table should not have join dependency i.e. if decomposing a table results in loss of information or creation of new info then don't do it."))))},{id:5,title:"File structure & Indexing",content:n.a.createElement("div",null,n.a.createElement("h1",null,"File structure ","&"," Indexing"),n.a.createElement("hr",null),n.a.createElement("p",null,"DB Files are stored in blocks in secondary memory in contiguous or non-contiguous manner."),n.a.createElement("b",null,"Sorted file"),n.a.createElement("ul",null,n.a.createElement("li",null,"Can be sorted only according to one attribute (search key)"),n.a.createElement("li",null,"Searching is fast (binary search)"),n.a.createElement("li",null,"Insertion and deletion will be hard")),n.a.createElement("b",null,"Unsorted file"),n.a.createElement("ul",null,n.a.createElement("li",null,"Random order"),n.a.createElement("li",null,"Searching is slow"),n.a.createElement("li",null,"Insertion and deletion is easy")),n.a.createElement("b",null,"Spanned mapping"),n.a.createElement("ul",null,n.a.createElement("li",null,"Internal fragmentation is avoided"),n.a.createElement("li",null,"If space is left in a block after storing file then next file is stored in this void partially")),n.a.createElement("b",null,"Unspanned mapping"),n.a.createElement("ul",null,n.a.createElement("li",null,"Internal fragmentation possible"),n.a.createElement("li",null,"File is put only if it fits the available space")),n.a.createElement("hr",null),n.a.createElement("h4",null,"Indexing"),n.a.createElement("p",null,"To search a record in db file, first find the block in which the record lies then find the record in that block. To speed up search we maintain a separate index file. Index file is small hence search is faster.",n.a.createElement("br",null),n.a.createElement("b",null,"Index file (search key, block pointer)"),n.a.createElement("br",null),"index file is always sorted (binary search applied)",n.a.createElement("br",null),"Blocking factor = no. of records in a block = floor(block size / record size)"),n.a.createElement("p",null,n.a.createElement("b",null,"Dense indexing :")," index record is present for all records in the main table. Sorted table not required",n.a.createElement("br",null),n.a.createElement("b",null,"Sparse indexing :")," index record is present for selected records of the main table. Sorted table required"),n.a.createElement("div",null,n.a.createElement("b",null,"Types of Indexing"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Single level indexing"),n.a.createElement("ol",null,n.a.createElement("li",null,"Primary indexing",n.a.createElement("ul",null,n.a.createElement("li",null,"Search key is primary key"),n.a.createElement("li",null,"File should be sorted on primary key"),n.a.createElement("li",null,"Sparse indexing"),n.a.createElement("li",null,"No. of index file entries = no. of blocks used by the main file"),n.a.createElement("li",null,"No. of accesses log(n) + 1"))),n.a.createElement("li",null,"Secondary indexing",n.a.createElement("ul",null,n.a.createElement("li",null,"Main file is not sorted"),n.a.createElement("li",null,"Dense indexing"),n.a.createElement("li",null,"Search key can be prime key or non key"),n.a.createElement("li",null,"Different techniques to store block pointers used when search keys are duplicated"),n.a.createElement("li",null,"Access time ceil(log(n)) + 1"))),n.a.createElement("li",null,"Clustered indexing",n.a.createElement("ul",null,n.a.createElement("li",null,"Similar to primary indexing but main file is sorted on non primary key but the attribute to be searched is not primary key"),n.a.createElement("li",null,"There will be one entry in the index for each unique value"),n.a.createElement("li",null,"Access resuired ",">","= log(n) + 1"),n.a.createElement("li",null,"It satisfies condition of both sparse and dense indexing"))))),n.a.createElement("li",null,n.a.createElement("b",null,"Multi-level indexing"),n.a.createElement("p",null,"If index is very large then we again split it to make multiple levels of indexing i.e we make index of index to speed up the search more.")))))},{id:6,title:"Transactions",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Transactions"),n.a.createElement("hr",null),n.a.createElement("p",null,n.a.createElement("b",null,"Transaction "),"is a set of instruction which performs a logical unit of work. They are atomic in nature, i.e if failure occur in the mid then it needs to rollback again to the start."),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"Transaction ACID properties"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Atomicity"),n.a.createElement("ul",null,n.a.createElement("li",null,"Either all instructions of a transaction will run or none"),n.a.createElement("li",null,"Transaction management component ensures atomicity in DBMS"))),n.a.createElement("li",null,n.a.createElement("b",null,"Consistency"),n.a.createElement("ul",null,n.a.createElement("li",null,"If DB is consistent before transaction then it should remain consistent after transaction"),n.a.createElement("li",null,n.a.createElement("b",null,"Eg.")," in case of account money transfer, total sum before and after the transfer should be same"),n.a.createElement("li",null,"No separate component takes care of consistency, it is automatically achieved if transaction is atomic, durable and isolated"))),n.a.createElement("li",null,n.a.createElement("b",null,"Isolation"),n.a.createElement("ul",null,n.a.createElement("li",null,"Transaction should be logically isolated i.e. transaction should not be affected by other transaction running concurrently"),n.a.createElement("li",null,"Transaction should produce same result as if it is running alone in the absence of other transactions"),n.a.createElement("li",null,"Concurrency control component ensures isolation in DBMS"))),n.a.createElement("li",null,n.a.createElement("b",null,"Durability"),n.a.createElement("ul",null,n.a.createElement("li",null,"Changes made by a successful transaction should be persistent in the system"),n.a.createElement("li",null,"Recovery management component ensures durability"))))),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"Transaction states"),n.a.createElement("ol",null,n.a.createElement("li",null,"Active (executing stage)"),n.a.createElement("li",null,"Partially committed (result stored in local buffer)"),n.a.createElement("li",null,"Committed (result copied to main store)"),n.a.createElement("li",null,"Terminated (final state) (system ready for next transaction)"),n.a.createElement("li",null,"Failed (some error occured and we then roll back)"),n.a.createElement("li",null,"Aborted (reached from failed state after roll back)")),n.a.createElement("p",null,"Committed transactions cannot be rollbacked. We can run a new transaction (compensating transaction) which undos the changed value.")))},{id:7,title:"Concurrency control",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Concurrency control"),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("b",null,"Advantages of concurrency"),n.a.createElement("ul",null,n.a.createElement("li",null,"Less wait time"),n.a.createElement("li",null,"Less response time"),n.a.createElement("li",null,"More resource utilization"),n.a.createElement("li",null,"More efficiency")),n.a.createElement("p",null,"Concurrency does not mean two instructions are running parallely. Transaction intructions are just interleaved."),n.a.createElement("b",null,"Disadvantages of concurrency"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Dirty read problem"),n.a.createElement("ul",null,n.a.createElement("li",null,"When a transaction reads an intermediate uncommitted value by some other transaction and treats it as a true value and commits to the main DB"),n.a.createElement("li",null,n.a.createElement("b",null,"Sol :")," the reading transaction commits after the other transaction writing its value has committed"))),n.a.createElement("li",null,n.a.createElement("b",null,"Unrepeatable read problem"),n.a.createElement("ul",null,n.a.createElement("li",null,"When a transaction reads a variable twice consecutively and gets different value each time because some other transaction has modified it in the time between."))),n.a.createElement("li",null,n.a.createElement("b",null,"Phantom read problem"),n.a.createElement("ul",null,n.a.createElement("li",null,"A transaction reads a variable, then another transaction deletes that variable and then again first transaction reads that variable and finds that the variable doesn't exist"))),n.a.createElement("li",null,n.a.createElement("b",null,"Lost update problem (write-write conflict)"),n.a.createElement("ul",null,n.a.createElement("li",null,"A transaction reads and writes a variable then another transaction performs blind write (write without reading before) on that variable then commits, after that first transaction commits. So here changes made by the first transaction is lost."))))),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"Types of schedule"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Serial schedule"),n.a.createElement("ul",null,n.a.createElement("li",null,"Transaction instructions are not interleaved"),n.a.createElement("li",null,"No context switching"))),n.a.createElement("li",null,n.a.createElement("b",null,"Non-serial schedule"),n.a.createElement("ul",null,n.a.createElement("li",null,"Transaction instructions are interleaved"),n.a.createElement("li",null,"Context switching happens"))),n.a.createElement("li",null,n.a.createElement("b",null,"Conflict serializable"),n.a.createElement("ul",null,n.a.createElement("li",null,"If we can make a non-serial schedule, serial by swapping instructions then that non-serial schedule is conflict serializable and is consistent. But if we cannot swap and make it serial then we cannot definitely say that it is inconsistent"),n.a.createElement("li",null,"If we can swap instruction then they are non-conflicting"),n.a.createElement("li",null,"When are instructions conflicting :",n.a.createElement("ol",null,n.a.createElement("li",null,"Instructions should be of different transactions"),n.a.createElement("li",null,"If instruction are on different data items then they are non-conflicting"),n.a.createElement("li",null,"RR on same data is non-conflicting"),n.a.createElement("li",null,"WR on same data are conflicting"),n.a.createElement("li",null,"WR on same data are conflicting"),n.a.createElement("li",null,"WW on same data are conflicting"))),n.a.createElement("li",null,"How to check for conflict serializability :",n.a.createElement("ul",null,n.a.createElement("li",null,"Draw graph",n.a.createElement("br",null),"T1 -",">"," T2 (transaction T1 must happen before T2)"),n.a.createElement("li",null,"If cycle present then it is not conflict serializable O(n",n.a.createElement("sup",null,"2"),")"))))),n.a.createElement("li",null,n.a.createElement("b",null,"View serializability"),n.a.createElement("ul",null,n.a.createElement("li",null,"Weaker form of consistency than conflict serializable"),n.a.createElement("li",null,"If schedule is CS then it will surely be VS"),n.a.createElement("li",null,"If a schedule is VS then we cannot say that it is surely CS"),n.a.createElement("li",null,"If a schedule is not CS then for it to be VS it has to have at least 1 blind write"),n.a.createElement("li",null,"To check for VS we have to check view equivalency of all permutations of transaction in a serial schedule with the given schedule",n.a.createElement("ul",null,n.a.createElement("li",null,"All initial reads on data item should be done by same transaction"),n.a.createElement("li",null,"All final writes on data should be done by same transaction"),n.a.createElement("li",null,"For all intermediate reads, the transaction should read the value written by same transaction in both the schedules"))))),n.a.createElement("li",null,n.a.createElement("b",null,"Recoverable schedule"),n.a.createElement("ul",null,n.a.createElement("li",null,"Even if schedule is consistent a failure can make it inconsistent"),n.a.createElement("li",null,"If dirty read is absent then it is recoverable"),n.a.createElement("li",null,"If dirty read present then the transaction doing the dirty read commits last then also its recoverable otherwise non recoverable"),n.a.createElement("p",null,n.a.createElement("b",null,"Cascading rollback :")," when one transaction rollbacks and on seeing this, another dependent transaction starts to roll back and so on ..."))),n.a.createElement("li",null,n.a.createElement("b",null,"Cascadeless schedule"),n.a.createElement("ul",null,n.a.createElement("li",null,"Transaction instantly commits before a dependent transaction performs a dirty read, hence dirty read is prevented and it becomes cascadeless"),n.a.createElement("li",null,"This is more restrictive form of recoverable schedule"),n.a.createElement("li",null,"If transaction is cascadeless then it is surely recoverable but vice versa is not always true"))),n.a.createElement("li",null,n.a.createElement("b",null,"Strict schedule"),n.a.createElement("ul",null,n.a.createElement("li",null,"If a transaction is performing write operation on a data item, then no other transaction can read or wire same data until first transaction has committed"),n.a.createElement("li",null,"It is most restrictive"))))),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"Concurrency control techniques"),n.a.createElement("div",null,n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Time stamping protocols"),n.a.createElement("div",null,n.a.createElement("ul",null,n.a.createElement("li",null,"Timestamp of a transaction : each transaction is stamped with time which is unique to resolve conflict in case of concurrency issues."),n.a.createElement("li",null,"Timestamp TS(T",n.a.createElement("sub",null,"i"),") of transaction i will be the value of the system clock when T",n.a.createElement("sub",null,"i")," entered into the system"),n.a.createElement("li",null,"If TS(T",n.a.createElement("sub",null,"i"),") ","<"," TS(T",n.a.createElement("sub",null,"j"),") then it is ensured that Ti runs before Tj Timestamp of data item"),n.a.createElement("li",null,"Each data item q maintains two timestamp (read and write)"),n.a.createElement("li",null,"R-timestamp(q) : largest timestamp of any transaction that executed read operation successfully"),n.a.createElement("li",null,"W-timestamp(q) : largest timestamp of any transaction that executed write operation successfully"),n.a.createElement("li",null,"T",n.a.createElement("sub",null,"i")," requests for read(q)"),n.a.createElement("ul",null,n.a.createElement("li",null,"If TS(T",n.a.createElement("sub",null,"i"),") ","<"," W.T.S(q) : Ti is rollbacked"),n.a.createElement("li",null,"If TS(T",n.a.createElement("sub",null,"i"),") ",">","= W.T.S(q) : T",n.a.createElement("sub",null,"i")," is allowed and R.T.S(q) will be max(R.T.S(q), TS(T",n.a.createElement("sub",null,"i"),"))")),n.a.createElement("li",null,"Ti requests for write(q)"),n.a.createElement("ul",null,n.a.createElement("li",null,"If TS(Ti) ","<"," R.T.S(q) : T",n.a.createElement("sub",null,"i")," is rollbacked"),n.a.createElement("li",null,"If TS(Ti) ","<"," W.T.S(q) : T",n.a.createElement("sub",null,"i")," is rollbacked"),n.a.createElement("li",null,"Else all condition T",n.a.createElement("sub",null,"i")," is allowed and W.T.S(q) will be max(W.T.S(q), TS(T",n.a.createElement("sub",null,"i"),"))")),n.a.createElement("li",null,"It ensures conflict serializability"),n.a.createElement("li",null,"It ensures view serializability (obviously)"),n.a.createElement("li",null,"Possibility of dirty read, no restrictions on commit, irrecoverable schedules and cascading rollbacks are possible"),n.a.createElement("li",null,"No possibility of deadlock (because we only allow or reject , no wait)"),n.a.createElement("li",null,"Slow"),n.a.createElement("li",null,"May suffer from from timestamp"),n.a.createElement("li",null,"Schedule generated by timestamp protocol is subset of conflict serializable schedule"),n.a.createElement("li",null,n.a.createElement("b",null,"Thomas write rule : "),"modify timestamp protocol to make some improvements and may generate those schedule that are VS but not CS and provides better concurrency"),n.a.createElement("li",null,"It modifies timestamp protocol in obsolete write case when T",n.a.createElement("sub",null,"i")," request write(q) if TS(T",n.a.createElement("sub",null,"i"),")","<","W.T.S(q)"),n.a.createElement("li",null,"Here T",n.a.createElement("sub",null,"i")," attempts to write an obsolete value of q. Rather than rolling back T",n.a.createElement("sub",null,"i"),", the write operation is just ignored.")))),n.a.createElement("li",null,n.a.createElement("b",null,"Lock based protocols"),n.a.createElement("div",null,n.a.createElement("ul",null,n.a.createElement("li",null,"Locking is done to achieve isolation and consistency"),n.a.createElement("li",null,"lock -",">"," perform operation -",">"," unlock"),n.a.createElement("li",null,"modes of locks"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Shared mode Lock-S(x) : "),"transaction can perform read operation. Any other transaction can also acquire the same lock on the same data item at the same time"),n.a.createElement("li",null,n.a.createElement("b",null,"Exclusive mode Lock-X(x) : "),"transaction can perform both read and write operations. Any other cannot acquire read/exclusive lock at the same time")),n.a.createElement("li",null,"If unlocking is not properly managed then inconsistency issues are possible. Hence we follow certain locking protocols"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"2 phase locking")," (basic, conservative, strict, rigorous)"),n.a.createElement("ul",null,n.a.createElement("li",null,"transaction can have only 2 phases"),n.a.createElement("ol",null,n.a.createElement("li",null,"Growing phase : transaction can only acquire lock and cannot release it"),n.a.createElement("li",null,"Shrinking phase : transaction can only release lock and cannot acquire")),n.a.createElement("li",null,"W/R operation can be performed in both phases"),n.a.createElement("li",null,"Ensures CS, the order of serializability is the order in which transaction reaches the lock point (when phase 1 ends and 2 begins)"),n.a.createElement("li",null,"May generate irrecoverable schedule and cascading rollbacks"),n.a.createElement("li",null,"May cause deadlock (waiting for locks)"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Conservative 2PL")),n.a.createElement("ul",null,n.a.createElement("li",null,"All locks are required for data items required at the start (lock point is the start point)"),n.a.createElement("li",null,"If lock is not available then it will release acquired locks and wait and then start again later"),n.a.createElement("li",null,"Free from deadlock"),n.a.createElement("li",null,"Prior knowledge of what data item to be used required"),n.a.createElement("li",null,"Possibility of irrecoverable schedule and cascading rollbacks (dirty read, commit issues)")),n.a.createElement("li",null,n.a.createElement("b",null,"Rigorous 2PL")),n.a.createElement("ul",null,n.a.createElement("li",null,"Improvement to provide recoverable and cascadeless schedule (no dirty read, commit issues)"),n.a.createElement("li",null,"All locks must be held till the end of transaction"),n.a.createElement("li",null,"Only in the end all locks are released"),n.a.createElement("li",null,"Lock point is the end of transaction"),n.a.createElement("li",null,"Deadlock possible and inefficient because lock is held throughout strict 2PL")),n.a.createElement("li",null,n.a.createElement("b",null,"Strict 2PL")),n.a.createElement("ul",null,n.a.createElement("li",null,"Improved version of rigorous 2PL"),n.a.createElement("li",null,"In shrinking phase unlocking of exclusive locks are not allowed but shared locks are allowed"),n.a.createElement("li",null,"All properties of rigorous 2PL + concurrency is improved")))),n.a.createElement("li",null,n.a.createElement("b",null,"Graph based")),n.a.createElement("ul",null,n.a.createElement("li",null,"Info. about the order in which db items will be accessed is required"),n.a.createElement("li",null,"Partial ordering is imposed d",n.a.createElement("sub",null,"i"),"-",">","d",n.a.createElement("sub",null,"j")," (d",n.a.createElement("sub",null,"i")," is accessed before d",n.a.createElement("sub",null,"j"),")"),n.a.createElement("li",null,"Set of all data items will be viewed as a DAG (aka db graph)"),n.a.createElement("li",null,"Will only use exclusive mode locks"),n.a.createElement("li",null,"Only considered rooted trees"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Tree protocol"),n.a.createElement("ul",null,n.a.createElement("li",null,"A transaction T",n.a.createElement("sub",null,"i")," may initially lock any data item"),n.a.createElement("li",null,"Subsequently a data item q can be locked only if q's parent is locked by Ti"),n.a.createElement("li",null,"Data item may be unlocked any time"),n.a.createElement("li",null,"Data item locked and then unlocked by Ti cannot be relocked by Ti"),n.a.createElement("li",null,"All schedules under this protocol are CS and VS"),n.a.createElement("li",null,"Deadlock not possible but starvation possible"),n.a.createElement("li",null,"Do not ensures recoverable and cascadeless-ness (it can be ensured by not unlocking before commit)"),n.a.createElement("li",null,"Transaction may lock data item which it doesn't require"))))))))),n.a.createElement("li",null,"Validation protocol")))))},{id:8,title:"Deadlocks",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Deadlocks"),n.a.createElement("hr",null),n.a.createElement("p",null,"Look OS Notes for intro"),n.a.createElement("hr",null),n.a.createElement("h4",null,"Dealing with deadlock problem"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"deadlock prevention")),n.a.createElement("ul",null,n.a.createElement("li",null,"To prevent hold and wait : use conservative-2PL"),n.a.createElement("li",null,"To prevent cyclic wait : use tree protocol"),n.a.createElement("li",null,"Wait and die approach (non preemptive)"),n.a.createElement("ul",null,n.a.createElement("li",null,"T",n.a.createElement("sub",null,"j")," has lock on Q. T",n.a.createElement("sub",null,"i")," wants to acquire lock on Q"),n.a.createElement("li",null,"If TS(T",n.a.createElement("sub",null,"i"),") ","<"," TS(T",n.a.createElement("sub",null,"j"),") -",">"," Ti must wait"),n.a.createElement("li",null,"If TS(T",n.a.createElement("sub",null,"i"),") ",">"," TS(T",n.a.createElement("sub",null,"j"),") -",">"," T",n.a.createElement("sub",null,"i")," is rollbacked (die)"),n.a.createElement("li",null,"On rollback it retains its original time stamp otherwise it is possible that it may never get a chance")),n.a.createElement("li",null,"Wound wait (preemptive)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Tj has lock on Q. Ti wants to acquire lock on Q"),n.a.createElement("li",null,"If TS(T",n.a.createElement("sub",null,"i"),") ",">"," TS(T",n.a.createElement("sub",null,"j"),") -",">"," T",n.a.createElement("sub",null,"i")," must wait"),n.a.createElement("li",null,"If TS(T",n.a.createElement("sub",null,"i"),") ","<"," TS(T",n.a.createElement("sub",null,"j"),") -",">"," T",n.a.createElement("sub",null,"j")," is rollbacked")),n.a.createElement("li",null,"Lock timeouts"),n.a.createElement("ul",null,n.a.createElement("li",null,"Threshold time is set for a transaction to acquire lock"),n.a.createElement("li",null,"If lock is not obtained within time, then it is rollbacked"))),n.a.createElement("li",null,n.a.createElement("b",null,"Detection and recovery"))),n.a.createElement("hr",null),n.a.createElement("p",null,n.a.createElement("sup",null,"*"),"OS Notes cover deadlock in more detail"))},{id:9,title:"SQL",content:n.a.createElement("div",null,n.a.createElement("h1",null,"SQL (Structured Query Language)"),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("b",null,"SQL")," is a standard language for relational database management systems",n.a.createElement("ul",null,n.a.createElement("li",null,"SQL is domain specific"),n.a.createElement("li",null,"SQL is not case sensitive")),n.a.createElement("b",null,"DDL : "),"data definition language",n.a.createElement("br",null),n.a.createElement("b",null,"DML : "),"data manipulation language",n.a.createElement("br",null),n.a.createElement("b",null,"TCL : "),"transaction control language",n.a.createElement("br",null)),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"General Query Syntax"),n.a.createElement("p",null,"SELECT attributes",n.a.createElement("br",null)," FROM table_name",n.a.createElement("br",null)," WHERE condition")),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"Cross table queries"),n.a.createElement("b",null,"Cartesian product "),"(every row in table-1 is associated to every row in table-2)",n.a.createElement("p",null,"SELECT ...",n.a.createElement("br",null),"FROM table1, table2",n.a.createElement("br",null),"WHERE table1.id = table2.id"),n.a.createElement("b",null,"Joins")," (improved version of cartesian product)",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Natural join"),n.a.createElement("br",null),"Considers same value of common attribute in 2 tables for matching"),n.a.createElement("p",null,"SELECT ...",n.a.createElement("br",null),"FROM table1 NATURAL JOIN table2",n.a.createElement("br",null),"WHERE ..."),n.a.createElement("li",null,n.a.createElement("b",null,"Join/Inner join"),n.a.createElement("br",null),"Inner join or just join, both are same"),n.a.createElement("ul",null,n.a.createElement("li",null,"Join based on an attribute"),n.a.createElement("p",null,"SELECT ...",n.a.createElement("br",null),"FROM table1 JOIN table2 using (id)"),n.a.createElement("li",null,"Join based on condition"),n.a.createElement("p",null,"SELECT ...",n.a.createElement("br",null),"FROM table1 JOIN table2 on table1.id = table2.id")),n.a.createElement("li",null,n.a.createElement("b",null,"Outer join"),n.a.createElement("br",null),"Problem of data loss in above joins (unmatched columns)",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Left outer join :")," full left table and matching of right table others NULL"),n.a.createElement("li",null,n.a.createElement("b",null,"Right outer join :")," full right table and matching of left table others NULL"),n.a.createElement("li",null,n.a.createElement("b",null,"Full outer join :")," full table with NULL in unmatched")))),n.a.createElement("b",null,"UNION, INTERSECT, MINUS/EXCEPT"),n.a.createElement("ul",null,n.a.createElement("p",null,"SELECT ...",n.a.createElement("br",null),"FROM ...",n.a.createElement("br",null),"UNION / INTERSECT / MINUS / EXCEPT",n.a.createElement("br",null),"SELECT ...",n.a.createElement("br",null),"FROM ..."),n.a.createElement("li",null,"For using it in queries, both tables should have same no. and types of columns."),n.a.createElement("li",null,"Union, intersect and minus/except automatically remove duplicate records."),n.a.createElement("li",null,"For keeping duplicate records use UNION ALL instead of UNION and likewise ..."))),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"String Operations"),n.a.createElement("p",null,"LIKE (like is case sensitive)",n.a.createElement("br",null),"'_' - character",n.a.createElement("br",null),"'%' - substring",n.a.createElement("br",null),"WHERE name LIKE '%das'",n.a.createElement("br",null),"WHERE name LIKE '_oel'")),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"Miscellaneous"),n.a.createElement("p",null,n.a.createElement("b",null,"Sorting by two attributes"),n.a.createElement("br",null),"SELECT ID, CompanyName, City, Country",n.a.createElement("br",null),"FROM Supplier",n.a.createElement("br",null),"WHERE Country IN ('USA', 'Japan', 'Germany')",n.a.createElement("br",null),"ORDER BY Country ASC, CompanyName DESC"),n.a.createElement("p",null,n.a.createElement("b",null,"Where conditions"),n.a.createElement("br",null),"WHERE condition (","<>"," not equal) (balance between 10 and 100)")),n.a.createElement("hr",null),n.a.createElement("div",null,n.a.createElement("h4",null,"NoSQL vs. SQL"),n.a.createElement("b",null,"NoSQL (not only SQL)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Flexible"),n.a.createElement("li",null,"Fast"),n.a.createElement("li",null,"Scalable"),n.a.createElement("li",null,"Suitable for large volume of data"),n.a.createElement("li",null,"Designed to scale out (more number of nodes)")),n.a.createElement("b",null,"SQL"),n.a.createElement("ul",null,n.a.createElement("li",null,"Rigid"),n.a.createElement("li",null,"Designed to scale up (bigger size of nodes)"),n.a.createElement("li",null,"Suitable for structured data")),n.a.createElement("b",null,"SQL is better when :"),n.a.createElement("ul",null,n.a.createElement("li",null,"Working with complex queries"),n.a.createElement("li",null,"ACID compliance"),n.a.createElement("li",null,"Less chance of changes or growth")),n.a.createElement("b",null,"NoSQL is better when :"),n.a.createElement("ul",null,n.a.createElement("li",null,"Constantly there is change data, schema or data type"),n.a.createElement("li",null,"There is large volume of data"))))}],f=function(e){var l=e.activeNoteID,t=e.showNav,a=e.handleClick;return n.a.createElement("div",{className:"row",style:{width:"80%",margin:"0 auto",paddingTop:"15px"}},!t&&n.a.createElement("div",{className:"col-3",style:{borderRight:"1px solid #eee"}},n.a.createElement(h,{notes:p,activeNoteID:l,handleClick:a})),n.a.createElement("div",{className:"col"},n.a.createElement(b,{note:p[l].content})))},y=function(e){Object(u.a)(t,e);var l=Object(s.a)(t);function t(){var e;Object(c.a)(this,t);for(var a=arguments.length,n=new Array(a),r=0;r<a;r++)n[r]=arguments[r];return(e=l.call.apply(l,[this].concat(n))).state={showResponsiveNav:!1,activeNoteID:0},e.handleClick=function(l){e.setState({activeNoteID:l})},e}return Object(o.a)(t,[{key:"resize",value:function(){var e=window.innerWidth<950;e!==this.state.showNav&&this.setState({showResponsiveNav:e})}},{key:"componentDidMount",value:function(){window.addEventListener("resize",this.resize.bind(this)),this.resize()}},{key:"componentWillUnmount",value:function(){window.removeEventListener("resize",this.resize.bind(this))}},{key:"render",value:function(){return n.a.createElement("div",null,n.a.createElement(d,{showNav:this.state.showResponsiveNav,notes:p,activeNoteID:this.state.activeNoteID,handleClick:this.handleClick}),n.a.createElement(f,{showNav:this.state.showResponsiveNav,activeNoteID:this.state.activeNoteID,handleClick:this.handleClick}))}}]),t}(a.Component);t(33);i.a.render(n.a.createElement(y,null),document.getElementById("root"))}},[[21,1,2]]]);
//# sourceMappingURL=main.309203d9.chunk.js.map